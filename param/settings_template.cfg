# GLOBAL:
  analyzeMode = 0                     # (int) True or False (1 or 0) to execute in analyze mode
  analyzeOutputDirectory = ./analysis/         # (string) where output files will be written in analysis mode
  mode = run                          # (string) mode to run MABE in [run,test]
  outputDirectory = ./output/                # (string) where files will be written
  popSize = 100                       # (int) number of genomes in the populaiton
  randomSeed = 101                    # (int) seed for random number generator, if -1 random number generator will be seeded randomly
  updates = 30000                      # (int) how long the program will run

# ARCHIVIST:
  aveFileColumns = []                 # (string) data to be saved into average file (must be values that can generate an average). If empty, MABE will try to figure it out
  aveFileName = ave.csv               # (string) name of average file (saves population averages)
  dominantFileName = dominant.csv     # (string) name of dominant file (saves data on dominant organism)
  dominantFileShowAllLists = 1        # (bool) lists named 'all'* in data map will be averaged and added to file. if true, raw 'all'* lists will also be added to the file
  realtimeFilesInterval = 100          # (int) How often to write to realtime data files
  writeAveFile = 1                    # (bool) Save data to average file?
  writeDominantFile = 1               # (bool) Save data to dominant file?

# ARCHIVIST - OUTPUT METHOD:
  outputMethod = SSwD              # (string) output method, [default, LODwAP (Line of Decent with Aggressive Pruning), snapshot, SSwD (SnapShot with Delay)]

# ARCHIVIST_LODWAP:
  dataFileConvertAllLists = 1         # (bool) if true, lists named 'all'* in data map will be averaged and added to file
  dataFileName_LODwAP = data.csv      # (string) name of genome file (stores genomes for line of decent)
  dataFileShowAllLists = 1            # (bool) if true, lists named 'all'* in data map will be saved
  dataInterval_LODwAP = 100           # (int) How often to write to data file
  genomeFileName_LODwAP = genome.csv  # (string) name of data file (stores everything but genomes)
  genomeInterval_LODwAP = 1000        # (int) How often to write genome file
  pruneInterval_LODwAP = 100          # (int) How often to attempt to prune LOD and actually write out to files
  terminateAfter_LODwAP = 100         # (int) how long to run after updates (to get better coalescence)
  writeDataFile_LODwAP = 1            # (bool) if true, a data file will be written
  writeGenomeFile_LODwAP = 1          # (bool) if true, a genome file will be written

# ARCHIVIST_SNAPSHOT:
  dataFilePrefix_SS = data            # (string) name of genome file (stores genomes)
  dataInterval_SS = 100               # (int) How often to save a data file
  genomeFilePrefix_SS = genome        # (string) name of data file (stores everything but genomes)
  genomeInterval_SS = 1000            # (int) How often to save a genome file
  writeDataFiles_SS = 1               # (bool) if true, data files will be written
  writeGenomeFiles_SS = 1             # (bool) if true, genome files will be written

# ARCHIVIST_SSWD:
  cleanupInterval_SSwD = 500          # (int) How often to cleanup old checkpoints
  dataFilePrefix_SSwD = data          # (string) name of genome file (stores genomes)
  dataIntervalDelay_SSwD = 500         # (int) when using Snap Shot with Delay output Method, how long is the delay before saving data
  dataInterval_SSwD = 500             # (int) How often to save a data file
  genomeFilePrefix_SSwD = genome      # (string) name of data file (stores everything but genomes)
  genomeIntervalDelay_SSwD = 500       # (int) when using Snap Shot with Delay output Method, how long is the delay before saving genomes
  genomeInterval_SSwD = 500          # (int) How often to save a genome file
  writeDataFiles_SSwD = 1             # (bool) if true, data files will be written
  writeGenomeFiles_SSwD = 1           # (bool) if true, genome files will be written

# BRAIN:
  bitsPerBrainAddress = 8             # (int) how many bits are evaluated to determine the brain addresses
  bitsPerCodon = 8                    # (int) how many bits are evaluated to determine the codon addresses
  brainType = Markov                  # (string) brain to be used in evolution loop, [Markov, Wire]
  hiddenNodes = 8                     # (int) number of hidden nodes, if brain type supports hiden nodes
  serialProcessing = 0                # (bool) outputs from units will write to nodes, not nodesNext

# BRAIN - WIRE:
  WireBrain_cacheResults = 1          # (bool) if true, t+1 nodes will be cached. If the same input is seen, the cached node values will be used.
  WireBrain_cacheResultsCount = 1     # (int) input combinations will be cached this many times, after this, repeats of a given input array will look up a random value from cached values
  allowNegativeCharge = 0             # (bool) if true, wire brain can interpret negative input, deliver negative output, and charge negatively
  bitmap_InitialFillRatio = 0.2       # (double) if bitmap genomeDecodingMethod: amount of the brain that will initially be wire vs. empty
  chargeUpdatesPerUpdate = 30         # (int) Number of charge updates per brain update
  constantInputs = 1                  # (bool) if true, input values are reset every charge update, if not, input values are set on first charge update only.
  decayDuration = 1                   # (int) length of time a cell will decay (while in decay a cell can not become charged)
  genomeDecodingMethod = bitmap       # (string) bitmap = convert genome directly, wiregenes = genes defined by start codeons, location, direction and location
  overchargeThreshold = 3             # (int) If a cell receives this much charge or more, it will not charge
  size_depth = 10                     # (int) depth of the wire brain cube
  size_height = 10                    # (int) height of the wire brain cube
  size_width = 10                     # (int) width of the wire brain cube
  worldConnectionsSeparation = 7      # (int) distance between nodes input and output connections (I/O)

# BRAIN - WIRE - WIREGENE:
  wiregenes_AllowSimpeWires = 1       # (bool) allow SimpleWire features (lengths of straight wire)
  wiregenes_AllowSquiggleWires = 0    # (bool) allow squiggleWire features (wires generated by converting genome into list of directions)
  wiregenes_AllowWormholes = 0        # (bool) allow Wormhole features (one directional links between distant wires)
  wiregenes_InitialGeneCount = 50     # (int) number of start codons to be inserted into inital genome
  wiregenes_SimpleWireDirections = cardinalOnly # (string) cardinalOnly (wires project in 6 square directions) vs diagonalsAlso (wires project on diagonals also)
  wiregenes_SimpleWireMaxLength = 1   # (int) maximum length of a SimpleWire (if 1, direction is effectively ignored). Wires that would project outside of brain are clipped
  wiregenes_SquiggleWireDirections = cardinalOnly # (string) cardinalOnly (wires project in 6 square directions) vs diagonalsAlso (wires project on diagonals also)
  wiregenes_SquiggleWireMaxLength = 10 # (int) maximum length of a SquiggleWire (if 1, it will look just like a SimpleWire). Wires that would project outside of brain are clipped
  wiregenes_SquiggleWireMinLength = 4 # (int) minimum length of a SquiggleWire (if 1, it will look just like a SimpleWire). Wires that would project outside of brain are clipped
  wiregenes_WormholesBidirectional = 0 # (int) allow Wormhole features to be bidirectional(0 = no, 1 = random, 2 = always)

# GATE TYPES:
  deterministicGate = 1               # (bool) set to true to enable deterministic gates?
  deterministicGate_InitialCount = 5  # (int) seed genome with this many start codons
  feedBackGate = 0                    # (bool) set to true to enable feedback gates
  feedBackGate_InitialCount = 0       # (int) seed genome with this many start codons
  fixedEpsilonGate = 0                # (bool) set to true to enable epsilon gates
  fixedEpsilonGate_InitialCount = 0   # (int) seed genome with this many start codons
  geneticProgramingGate = 0           # (bool) set to true to enable GP (what?) gates
  geneticProgramingGate_InitialCount = 0 # (int) seed genome with this many start codons
  neuronGate = 0                      # (bool) set to true to enable Neuron gates
  neuronGateGate_InitialCount = 0     # (int) seed genome with this many start codons
  probabilisticGate = 1               # (bool) set to true to enable probabilistic gates
  probabilisticGate_InitialCount = 5  # (int) seed genome with this many start codons
  thresholdGate = 0                   # (bool) set to true to enable threshold gates
  thresholdGate_InitialCount = 0      # (int) seed genome with this many start codons
  tritDeterministicGate = 0           # (bool) set to true to enable tritDeterministic gates
  tritDeterministicGateGate_InitialCount = 0 # (int) seed genome with this many start codons
  voidGate = 0                        # (bool) set to true to enable void gates
  voidGate_InitialCount = 0           # (int) seed genome with this many start codons

# GATES - FIXED EPSILON:
  fixedEpsilonGate_Probability = 0.05 # (double) chance that an output from a FixedEpsilonGate gate will be randomized

# GATES - GP:
  gpGate_constValueMax = 1            # (int) for the const values, max value the genome can generate
  gpGate_constValueMin = -1           # (int) for the const values, min value the genome can generate

# GATES - NEURON:
  dischargeBehavior = 0               # (int) what happens when gate fires (-1: let genome decide, 0: clear charge, 1: 'reduce' by delivery charge, 2: 1/2 charge)
  neuronGate_allowRepression = 0      # (bool) if false, neuronGates only fire if charge exceeds threshold; if true, neuronGates can also exist which always fire, except when charge exceeds threshold
  neuronGate_decayRateMax = 0         # (double) amount charge will decay (towards 0) per update
  neuronGate_decayRateMin = 0         # (double) amount charge will decay (towards 0) per update
  neuronGate_deliveryChargeFromNode = 0 # (bool) if true, gate will have additional input, which will be used as deliveryCharge
  neuronGate_deliveryChargeMax = 1    # (double) output charge
  neuronGate_deliveryChargeMin = -1   # (double) output charge
  neuronGate_deliveryError = 0        # (double) error in deliveryCharge... charge -= random[0,deliveryError)
  neuronGate_numInputsMax = 3         # (int) max number of inputs to neuronGate
  neuronGate_numInputsMin = 3         # (int) min number of inputs to neuronGate
  neuronGate_thresholdFromNode = 0    # (bool) if true, gate will have additional input, which will be used as threshold
  neuronGate_thresholdMax = 1         # (double) highest possible value for threshold
  neuronGate_thresholdMin = -1        # (double) lowest possible value for threshold

# GATES - VOID:
  voidGate_Probability = 0.05         # (double) chance that an output from a void gate will be set to 0

# GENOME:
  genomeAlphabetSize = 256            # (int) alphabet size for genome
  genomeSitesType = char              # (string) type for sites in genome [char, int, double, bool]
  genomeType = Multi                  # (string) genome to be used in evolution loop, [Multi, Circular]

# GENOME - CIRCULAR:
  circularGenome_SizeInitial = 2000   # (int) starting size for genome
  circularGenome_SizeMax = 5000       # (int) if genome is larger then this, mutations will only decrease chromosome size
  circularGenome_SizeMin = 400        # (int) if genome is smaller then this, mutations will only increase chromosome size
  circularGenome_crossCount = 3       # (int) number of crosses when performing crossover
  circularGenome_mutationCopyMaxSize = 200 # (int) maximum size of insertion mutation
  circularGenome_mutationCopyMinSize = 10 # (int) minimum size of insertion mutation
  circularGenome_mutationCopyRate = 2e-05 # (double) per site insertion rate
  circularGenome_mutationDeletionMaxSize = 200 # (int) maximum size of insertion mutation
  circularGenome_mutationDeletionMinSize = 10 # (int) minimum size of insertion mutation
  circularGenome_mutationDeletionRate = 2e-05 # (double) per site deletion rate
  circularGenome_pointMutationRate = 0.005 # (double) per site point mutation rate

# GENOME - MULTI:
  chromosomeSizeInitial = 10000       # (int) starting size for all chromosomes in genome (genome size will be chromosomeSizeInitial * number of chromosomes * ploidy)
  chromosomeSizeMax = 20000           # (int) if a chromosome is larger then this, mutations will only decrease chromosome size
  chromosomeSizeMin = 400             # (int) if a chromosome is smaller then this, mutations will only increase chromosome size
  chromosomes = 1                     # (int) number of chromosome pairs (i.e. if chromosomes = 2 and ploidy = 2 there will be 4 chromosomes in the genome)
  genomecrossCount = 3                # (int) number of crosses when performing crossover
  mutationCopyMaxSize = 200           # (int) maximum size of insertion mutation
  mutationCopyMinSize = 10            # (int) minimum size of insertion mutation
  mutationCopyRate = 2e-05            # (double) per site insertion rate
  mutationDeletionMaxSize = 200       # (int) maximum size of insertion mutation
  mutationDeletionMinSize = 10        # (int) minimum size of insertion mutation
  mutationDeletionRate = 2e-05        # (double) per site deletion rate
  ploidy = 1                          # (int) number of copies of each chromosome
  pointMutationRate = 0.005           # (double) per site point mutation rate

# MAIN:
  MAIN_genomeFileToAnalyze = ./output/genome_50000.csv # (string) Genome file to load and analyze in analysis mode.

# OPTIMIZER:
  elitism = 0                         # (int) if the chosen optimizer allows for elitism, The highest scoring brain will be included in the next generation this many times (0 = no elitism)?
  optimizer = GA                      # (string) optimizer to be used in evolution loop, [GA, Tournament, Tournament2]

# OPTIMIZER - TOURNAMENT:
  tournamentSize = 5                  # (int) how many genomes to consider when doing Tournament selection? 1 will result in random selection.

# WORLD:
  repeats = 3                         # (int) Number of times to test each Genome per generation

# WORLD - BERRY:
  BERRY_WorldUpdates = 400            # (int) amount of time an brain is tested
  BERRY_WorldX = 8                    # (int) world X size
  BERRY_WorldY = 8                    # (int) world Y size
  BERRY_clearOutputs = 0              # (bool) if true outputs will be cleared on each world update
  BERRY_foodTypes = 2                 # (int) number of types of food
  BERRY_makeBorderWalls = 1           # (bool) if true world will have a bounding wall
  BERRY_rewardForFood1 = 1            # (double) reward for eating a Food1
  BERRY_rewardForFood2 = 1            # (double) reward for eating a Food2
  BERRY_rewardForFood3 = 1            # (double) reward for eating a Food3
  BERRY_rewardForFood4 = 1            # (double) reward for eating a Food4
  BERRY_rewardForFood5 = 1            # (double) reward for eating a Food5
  BERRY_rewardForFood6 = 1            # (double) reward for eating a Food6
  BERRY_rewardForFood7 = 1            # (double) reward for eating a Food7
  BERRY_rewardForFood8 = 1            # (double) reward for eating a Food8
  BERRY_senseDown = 1                 # (bool) if true, Agent can sense what it's standing on
  BERRY_senseFront = 1                # (bool) if true, Agent can sense what's in front of it
  BERRY_senseFrontSides = 0           # (bool) if true, Agent can sense what's in front to the left and right of it
  BERRY_senseWalls = 0                # (bool) if true, Agent can sense Walls
  BERRY_taskSwitchingCost = 1.4       # (double) cost to change food sources

# WORLD - BERRY - ADVANCED:
  BERRY_allowMoveAndEat = 0           # (bool) if true, the brain can move and eat in the same world update
  BERRY_makeRandomWalls = 0           # (int) add this many walls to the world
  BERRY_recordConsumptionRatio = 0    # (bool) if true, record greater of red/blue+1 or blue/red+1
  BERRY_recordFoodList = 1            # (bool) if true, record list of food eaten
  BERRY_recordFoodListEatEmpty = 0    # (bool) if true, foodList will include attempts to eat 0
  BERRY_recordFoodListNoEat = 0       # (bool) if true, if true foodList will include no eat (-1)
  BERRY_replacement = -1              # (int) -1 = random, 0 = no replacement, 1 = replace other (note: Food0, can be replace by Food0)
  BERRY_replacementRatioFood0 = 0     # (int) Relative likelihood to leave empty space empty
  BERRY_replacementRatioFood1 = 1     # (int) Relative likelihood to place Food1
  BERRY_replacementRatioFood2 = 1     # (int) Relative likelihood to place Food2
  BERRY_replacementRatioFood3 = 1     # (int) Relative likelihood to place Food3
  BERRY_replacementRatioFood4 = 1     # (int) Relative likelihood to place Food4
  BERRY_replacementRatioFood5 = 1     # (int) Relative likelihood to place Food5
  BERRY_replacementRatioFood6 = 1     # (int) Relative likelihood to place Food6
  BERRY_replacementRatioFood7 = 1     # (int) Relative likelihood to place Food7
  BERRY_replacementRatioFood8 = 1     # (int) Relative likelihood to place Food8
  BERRY_rewardForMove = 0             # (double) reward for moving
  BERRY_rewardForTurn = 0             # (double) reward for turning

# WORLD - FORAGE:
  FORAGE_areaSize = 64                # (int) area size -- how large is the food area in the middle of the world (area size X area size)
  FORAGE_granularity = 1              # (int) granularity -- the number of possible four cell squares to forage from
  FORAGE_predictability = 1           # (double) predictability -- how predictable the world refreshes food
  FORAGE_randomizeBehavior = 0        # (int) if set (1), organisms will behave randomly (brains aren't used)
  FORAGE_runTime = 4096               # (int) run time -- how long should the organism be allowed to forage
  FORAGE_tickLength = 256             # (int) tick length -- after how many ticks should the world change
